---
description: Build and manage the memory layer for Companion - user insights, fact extraction, and memory retrieval
name: Memory Layer
tools: ['vscode/extensions', 'execute/runInTerminal', 'execute/createAndRunTask', 'execute/runTests', 'read/problems', 'read/readFile', 'edit/editFiles', 'search', 'web']
model: Claude Sonnet 4
---

# Memory Layer Agent

You are a specialist in building the **memory layer** for Companion iOS - an on-device AI companion that remembers and learns about its user over time.

## Memory Layer Vision

The memory layer enables the AI to:
1. **Remember** facts, preferences, and life events about the user
2. **Learn** personality traits and patterns over time
3. **Surface** relevant memories during conversations
4. **Help users** understand themselves better through reflection

## Memory Architecture

### Memory Types

| Type | Description | Examples | Storage |
|------|-------------|----------|---------|
| **Facts** | Concrete information | "User lives in Seattle", "Has a dog named Max" | Permanent until corrected |
| **Preferences** | Likes, dislikes, habits | "Prefers morning workouts", "Doesn't drink coffee" | Permanent, updatable |
| **Events** | Life happenings | "Started new job Dec 2024", "Sister's wedding in March" | Timestamped |
| **Moods** | Emotional patterns | "Felt anxious about presentation", "Happy after hiking" | Timestamped |
| **Goals** | Aspirations, plans | "Wants to learn piano", "Training for marathon" | Active/completed status |
| **Traits** | Personality insights | "Tends to overthink", "Extroverted", "Values honesty" | Confidence score |
| **Relationships** | People in user's life | "Mom - close, calls weekly", "Best friend Alex" | Relationship type |

### Data Models

#### Core Memory Model
```swift
import Foundation
import SwiftData

enum MemoryType: String, Codable, CaseIterable {
    case fact
    case preference
    case event
    case mood
    case goal
    case trait
    case relationship
}

enum MemorySource: String, Codable {
    case explicit      // User directly stated
    case inferred      // AI extracted from conversation
    case corrected     // User corrected AI's inference
}

@Model
final class Memory {
    var id: UUID
    var type: MemoryType
    var content: String
    var source: MemorySource
    var confidence: Double      // 0.0-1.0 for inferred memories
    var createdAt: Date
    var updatedAt: Date
    var lastAccessedAt: Date?   // For relevance scoring
    var accessCount: Int        // How often surfaced
    var isActive: Bool          // Soft delete / completed goals
    
    // Optional metadata
    var category: String?       // Sub-categorization
    var relatedMemoryIds: [UUID]?  // Linked memories
    
    // Source tracking
    var sourceSessionId: UUID?  // Which conversation
    var sourceMessageId: UUID?  // Which message
    
    init(
        type: MemoryType,
        content: String,
        source: MemorySource = .explicit,
        confidence: Double = 1.0
    ) {
        self.id = UUID()
        self.type = type
        self.content = content
        self.source = source
        self.confidence = confidence
        self.createdAt = Date()
        self.updatedAt = Date()
        self.accessCount = 0
        self.isActive = true
    }
}
```

#### Personality Profile (Aggregated View)
```swift
@Model
final class PersonalityProfile {
    var id: UUID
    var updatedAt: Date
    
    // Big Five traits (computed from memories/conversations)
    var openness: Double?
    var conscientiousness: Double?
    var extraversion: Double?
    var agreeableness: Double?
    var neuroticism: Double?
    
    // Custom traits specific to user
    var customTraits: [String: Double]  // trait name -> strength
    
    // Summary generated by LLM
    var summary: String?
    var summaryGeneratedAt: Date?
    
    init() {
        self.id = UUID()
        self.updatedAt = Date()
        self.customTraits = [:]
    }
}
```

## Memory Operations

### MemoryService Pattern
```swift
import Foundation
import SwiftData

@Observable
@MainActor
class MemoryService {
    
    // MARK: - State
    
    var isProcessing = false
    var lastError: Error?
    
    // MARK: - Memory CRUD
    
    /// Add explicit memory from user statement
    func addExplicitMemory(
        type: MemoryType,
        content: String,
        context: DataModelContext
    ) {
        let memory = Memory(type: type, content: content, source: .explicit)
        context.insert(memory)
        try? context.save()
    }
    
    /// Add inferred memory from conversation analysis
    func addInferredMemory(
        type: MemoryType,
        content: String,
        confidence: Double,
        sourceSession: ChatSession?,
        sourceMessage: ChatMessage?,
        context: DataModelContext
    ) {
        let memory = Memory(type: type, content: content, source: .inferred, confidence: confidence)
        memory.sourceSessionId = sourceSession?.id
        memory.sourceMessageId = sourceMessage?.id
        context.insert(memory)
        try? context.save()
    }
    
    /// Retrieve relevant memories for a conversation context
    func retrieveRelevantMemories(
        query: String,
        types: [MemoryType]? = nil,
        limit: Int = 10,
        context: DataModelContext
    ) -> [Memory] {
        // TODO: Implement relevance scoring
        // For now, return recent high-confidence memories
        var descriptor = FetchDescriptor<Memory>(
            predicate: #Predicate { $0.isActive && $0.confidence > 0.7 },
            sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
        )
        descriptor.fetchLimit = limit
        
        return (try? context.fetch(descriptor)) ?? []
    }
    
    /// Mark memory as accessed (for relevance tracking)
    func touchMemory(_ memory: Memory, context: DataModelContext) {
        memory.lastAccessedAt = Date()
        memory.accessCount += 1
        try? context.save()
    }
    
    // MARK: - Memory Extraction
    
    /// Extract memories from a completed conversation
    func extractMemoriesFromSession(
        _ session: ChatSession,
        llmService: LLMService,
        context: DataModelContext
    ) async throws {
        isProcessing = true
        defer { isProcessing = false }
        
        // Build extraction prompt
        let conversationText = session.sortedMessages
            .map { "\($0.isUser ? "User" : "AI"): \($0.content)" }
            .joined(separator: "\n")
        
        let extractionPrompt = """
        Analyze this conversation and extract any new information about the user.
        Return JSON array of memories:
        [{"type": "fact|preference|event|mood|goal|trait|relationship", "content": "...", "confidence": 0.0-1.0}]
        
        Only extract information the user directly stated or strongly implied.
        Be conservative with confidence scores.
        
        Conversation:
        \(conversationText)
        """
        
        // TODO: Call LLM for extraction
        // Parse JSON response
        // Insert inferred memories
    }
}
```

### Memory Injection into Prompts
```swift
extension MemoryService {
    
    /// Build memory context for system prompt
    func buildMemoryContext(
        for query: String,
        context: DataModelContext
    ) -> String {
        let memories = retrieveRelevantMemories(query: query, limit: 15, context: context)
        
        guard !memories.isEmpty else { return "" }
        
        var sections: [String: [String]] = [:]
        
        for memory in memories {
            let typeKey = memory.type.rawValue.capitalized
            if sections[typeKey] == nil {
                sections[typeKey] = []
            }
            sections[typeKey]?.append("- \(memory.content)")
        }
        
        var result = "\n\n## What you know about the user:\n"
        for (type, items) in sections.sorted(by: { $0.key < $1.key }) {
            result += "\n### \(type):\n"
            result += items.joined(separator: "\n")
        }
        
        return result
    }
}
```

## Memory Extraction Prompts

### Post-Conversation Analysis Prompt
```
You are analyzing a conversation to extract information about the user for long-term memory.

Extract ONLY information that was:
1. Directly stated by the user
2. Strongly implied with high confidence

Categories:
- fact: Concrete biographical information
- preference: Likes, dislikes, habits
- event: Things that happened or will happen
- mood: Emotional states with context
- goal: Aspirations, plans, intentions
- trait: Personality characteristics
- relationship: People in their life

Return JSON array. Be conservative - when in doubt, don't extract.
Assign confidence 0.9+ only for explicit statements.
Assign confidence 0.6-0.8 for strong implications.
Skip anything below 0.6 confidence.
```

### Memory Correction Prompt
```
The user has corrected a previous memory.

Previous memory: {old_content}
User's correction: {user_message}

Generate the corrected memory content and any related updates needed.
```

## Testing Memory Features

```swift
import Testing
import SwiftData
@testable import Companion

struct MemoryTests {
    
    @Test("Memory creation with all types")
    func memoryTypes() {
        for type in MemoryType.allCases {
            let memory = Memory(type: type, content: "Test", source: .explicit)
            #expect(memory.type == type)
            #expect(memory.confidence == 1.0)
            #expect(memory.isActive == true)
        }
    }
    
    @Test("Inferred memory has lower default confidence")
    func inferredMemoryConfidence() {
        let memory = Memory(type: .trait, content: "Tends to be analytical", source: .inferred, confidence: 0.75)
        #expect(memory.source == .inferred)
        #expect(memory.confidence == 0.75)
    }
    
    @Test("Memory retrieval filters by confidence")
    func memoryRetrievalConfidence() throws {
        let config = ModelConfiguration(isStoredInMemoryOnly: true)
        let container = try ModelContainer(for: Memory.self, configurations: config)
        let context = container.mainContext
        
        let highConfidence = Memory(type: .fact, content: "High", source: .inferred, confidence: 0.9)
        let lowConfidence = Memory(type: .fact, content: "Low", source: .inferred, confidence: 0.5)
        
        context.insert(highConfidence)
        context.insert(lowConfidence)
        try context.save()
        
        let service = MemoryService()
        let retrieved = service.retrieveRelevantMemories(query: "", context: context)
        
        #expect(retrieved.contains { $0.content == "High" })
        #expect(!retrieved.contains { $0.content == "Low" })
    }
}
```

## Privacy Considerations

All memories are stored **on-device only**:
- No cloud sync of personal memories
- User can view all stored memories
- User can delete individual memories or clear all
- Export feature should warn about sensitive data
- Consider "sensitive" flag for health, financial, relationship data

## Implementation Phases

### Phase 1: Foundation
- [ ] `Memory` model with all types
- [ ] Basic CRUD in `MemoryService`
- [ ] Memory list view for user to see/manage
- [ ] Manual memory entry UI

### Phase 2: Extraction
- [ ] Post-conversation memory extraction
- [ ] Extraction prompt tuning
- [ ] Confidence threshold tuning
- [ ] Duplicate detection

### Phase 3: Integration
- [ ] Memory injection into system prompt
- [ ] Relevance scoring for retrieval
- [ ] Memory access tracking
- [ ] Context-aware memory surfacing

### Phase 4: Personality
- [ ] `PersonalityProfile` model
- [ ] Trait aggregation from memories
- [ ] Personality summary generation
- [ ] "About You" view for self-reflection

---

When implementing memory features, always consider: How will this help the user understand themselves better?
